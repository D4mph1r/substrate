<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Try-runtime"><meta name="keywords" content="rust, rustlang, rust-lang, try_runtime_cli"><title>try_runtime_cli - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceSerif4-Regular-1f7d512b176f0f72.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceSerif4-Bold-124a1ca42af929b6.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2"><link rel="stylesheet" href="../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../static.files/rustdoc-3dd8914bdd6e2ce5.css" id="mainThemeStyle"><link rel="stylesheet" id="themeStyle" href="../static.files/light-1469fca9efc07bcb.css"><link rel="stylesheet" disabled href="../static.files/dark-e9b7e5d8ba0dc980.css"><link rel="stylesheet" disabled href="../static.files/ayu-0c1cf144240c9f40.css"><script id="default-settings" ></script><script src="../static.files/storage-d43fa987303ecbbb.js"></script><script defer src="../crates.js"></script><script defer src="../static.files/main-799a64abec831f72.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-13285aec31fa243e.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-16x16-8b506e7a72182f1c.png"><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="sidebar-logo" href="../try_runtime_cli/index.html"><div class="logo-container"><img class="rust-logo" src="../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></div></a><h2></h2></nav><nav class="sidebar"><a class="sidebar-logo" href="../try_runtime_cli/index.html"><div class="logo-container"><img class="rust-logo" src="../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></div></a><h2 class="location"><a href="#">Crate try_runtime_cli</a></h2><div class="sidebar-elems"><ul class="block"><li class="version">Version 0.10.0-dev</li><li><a id="all-types" href="all.html">All Items</a></li></ul><section><ul class="block"><li><a href="#modules">Modules</a></li><li><a href="#structs">Structs</a></li><li><a href="#enums">Enums</a></li></ul></section></div></nav><main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><input class="search-input" name="search" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" title="help" tabindex="-1"><a href="../help.html">?</a></div><div id="settings-menu" tabindex="-1"><a href="../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../static.files/wheel-5ec35bf9ca753509.svg"></a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1 class="fqn">Crate <a class="mod" href="#">try_runtime_cli</a><button id="copy-path" onclick="copy_path(this)" title="Copy item path to clipboard"><img src="../static.files/clipboard-7571035ce49a181d.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><a class="srclink" href="../src/try_runtime_cli/lib.rs.html#18-1004">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><details class="rustdoc-toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><h2 id="try-runtime"><a href="#try-runtime">Try-runtime</a></h2>
<p>Substrate’s ultimate testing framework for the power users.</p>
<blockquote>
<p>As the name suggests, <code>try-runtime</code> is a detailed testing framework that gives you a lot of
control over what is being executed in which environment. It is recommended that user’s first
familiarize themselves with substrate in depth, particularly the execution model. It is critical
to deeply understand how the wasm/client/runtime interactions, and the runtime apis work in the
substrate runtime, before commencing to working with <code>try-runtime</code>.</p>
</blockquote>
<h5 id="resources"><a href="#resources">Resources</a></h5>
<p>Some resources about the above:</p>
<ol>
<li><a href="https://docs.substrate.io/v3/tools/try-runtime">https://docs.substrate.io/v3/tools/try-runtime</a></li>
<li><a href="https://www.crowdcast.io/e/substrate-seminar/41">https://www.crowdcast.io/e/substrate-seminar/41</a></li>
<li><a href="https://docs.substrate.io/v3/advanced/executor">https://docs.substrate.io/v3/advanced/executor</a></li>
</ol>
<hr />
<h3 id="background-knowledge"><a href="#background-knowledge">Background Knowledge</a></h3>
<p>The basis of all try-runtime commands is the same: connect to a live node, scrape its <em>state</em>
and put it inside a <code>TestExternalities</code>, then call into a <em>specific runtime-api</em> using the given
state and some <em>runtime</em>.</p>
<p>Alternatively, the state could come from a snapshot file.</p>
<p>All of the variables in the above statement are made <em>italic</em>. Let’s look at each of them:</p>
<ol>
<li>
<p><strong>State</strong> is the key-value pairs of data that comprise the canonical information that any
blockchain is keeping. A state can be full (all key-value pairs), or be partial (only pairs
related to some pallets/prefixes). Moreover, some keys are especial and are not related to
specific pallets, known as <a href="../sp_storage/well_known_keys/index.html" title="well_known_keys"><code>well_known_keys</code></a> in substrate. The most important of these is
the <code>:CODE:</code> key, which contains the code used for execution, when wasm execution is chosen.</p>
</li>
<li>
<p><em>A runtime-api</em> call is a call into a function defined in the runtime, <em>on top of a given
state</em>. Each subcommand of <code>try-runtime</code> utilizes a specific <em>runtime-api</em>.</p>
</li>
<li>
<p>Finally, the <strong>runtime</strong> is the actual code that is used to execute the aforementioned
runtime-api. Everything in this crate assumes wasm execution, which means the runtime that
you use is the one stored onchain, namely under the <code>:CODE:</code> key.</p>
</li>
</ol>
<p>To recap, a typical try-runtime command does the following:</p>
<ol>
<li>Download the state of a live chain, and write to an <code>externalities</code>.</li>
<li>Overwrite the <code>:CODE:</code> with a given wasm blob</li>
<li>Test some functionality via calling a runtime-api.</li>
</ol>
<h3 id="usage"><a href="#usage">Usage</a></h3>
<p>To use any of the provided commands, <a href="struct.SharedParams.html" title="SharedParams"><code>SharedParams</code></a> must be provided. The most important of
which being <a href="struct.SharedParams.html#structfield.runtime" title="SharedParams::runtime"><code>SharedParams::runtime</code></a>, which specifies which runtime to use. Furthermore,
<a href="struct.SharedParams.html#structfield.overwrite_state_version" title="SharedParams::overwrite_state_version"><code>SharedParams::overwrite_state_version</code></a> can be used to alter the state-version (see
<a href="https://forum.polkadot.network/t/state-trie-migration/852">https://forum.polkadot.network/t/state-trie-migration/852</a> for more info).</p>
<p>Then, the specific command has to be specified. See <a href="enum.Command.html" title="Command"><code>Command</code></a> for more information about each
command’s specific customization flags, and assumptions regarding the runtime being used.</p>
<p>Said briefly, this CLI is capable of executing:</p>
<ul>
<li><a href="enum.Command.html#variant.OnRuntimeUpgrade" title="Command::OnRuntimeUpgrade"><code>Command::OnRuntimeUpgrade</code></a>: execute all the <code>on_runtime_upgrade</code> hooks.</li>
<li><a href="enum.Command.html#variant.ExecuteBlock" title="Command::ExecuteBlock"><code>Command::ExecuteBlock</code></a>: re-execute the given block.</li>
<li><a href="enum.Command.html#variant.OffchainWorker" title="Command::OffchainWorker"><code>Command::OffchainWorker</code></a>: re-execute the given block’s offchain worker code path.</li>
<li><a href="enum.Command.html#variant.FollowChain" title="Command::FollowChain"><code>Command::FollowChain</code></a>: continuously execute the blocks of a remote chain on top of a given
runtime.</li>
<li><a href="enum.Command.html#variant.CreateSnapshot" title="Command::CreateSnapshot"><code>Command::CreateSnapshot</code></a>: Create a snapshot file from a remote node.</li>
</ul>
<p>Finally, To make sure there are no errors regarding this, always run any <code>try-runtime</code> command
with <code>executor=trace</code> logging targets, which will specify which runtime is being used per api
call. Moreover, <code>remote-ext</code>, <code>try-runtime</code> and <code>runtime</code> logs targets will also be useful.</p>
<h3 id="spec-name-check"><a href="#spec-name-check">Spec name check</a></h3>
<p>A common pitfall is that you might be running some test on top of the state of chain <code>x</code>, with
the runtime of chain <code>y</code>. To avoid this all commands do a spec-name check before executing
anything by default. This will check the, if any alterations are being made to the <code>:CODE:</code>,
then the spec names match. The spec versions are warned, but are not mandated to match.</p>
<blockquote>
<p>If anything, in most cases, we expect spec-versions to NOT match, because try-runtime is all
about testing unreleased runtimes.</p>
</blockquote>
<h3 id="note-on-nodes-that-respond-to-try-runtime-requests"><a href="#note-on-nodes-that-respond-to-try-runtime-requests">Note on nodes that respond to <code>try-runtime</code> requests.</a></h3>
<p>There are a number of flags that need to be preferably set on a running node in order to work
well with try-runtime’s expensive RPC queries:</p>
<ul>
<li>set <code>--rpc-max-response-size 1000</code> and</li>
<li><code>--rpc-max-request-size 1000</code> to ensure connections are not dropped in case the state is
large.</li>
<li>set <code>--rpc-cors all</code> to ensure ws connections can come through.</li>
</ul>
<p>Note that <em>none</em> of the try-runtime operations need unsafe RPCs.</p>
<h3 id="note-on-signature-and-state-root-checks"><a href="#note-on-signature-and-state-root-checks">Note on signature and state-root checks</a></h3>
<p>All of the commands calling into <code>TryRuntime_execute_block</code> (<a href="enum.Command.html#variant.ExecuteBlock" title="Command::ExecuteBlock"><code>Command::ExecuteBlock</code></a> and
<a href="enum.Command.html#variant.FollowChain" title="Command::FollowChain"><code>Command::FollowChain</code></a>) disable both state root and signature checks. This is because in 99%
of the cases, the runtime that is being tested is different from the one that is stored in the
canonical chain state. This implies:</p>
<ol>
<li>the state root will NEVER match, because <code>:CODE:</code> is different between the two.</li>
<li>replaying all transactions will fail, because the spec-version is part of the transaction
signature.</li>
</ol>
<h3 id="best-practices"><a href="#best-practices">Best Practices</a></h3>
<p>Try-runtime is all about battle-testing unreleased runtime. The following list of suggestions
help developers maximize the testing coverage and make base use of <code>try-runtime</code>.</p>
<h5 id="adding-prepost-hooks"><a href="#adding-prepost-hooks">Adding pre/post hooks</a></h5>
<p>One of the gems that come only in the <code>try-runtime</code> feature flag is the <code>pre_upgrade</code> and
<code>post_upgrade</code> hooks for <code>OnRuntimeUpgrade</code>. This trait is implemented either inside the pallet,
or manually in a runtime, to define a migration. In both cases, these functions can be added,
given the right flag:</p>

<div class="example-wrap ignore"><div class='tooltip'>ⓘ</div><pre class="rust rust-example-rendered"><code> 
<span class="attr">#[cfg(feature = <span class="kw">try</span>-runtime)]
</span><span class="kw">fn </span>pre_upgrade() -&gt; <span class="prelude-ty">Result</span>&lt;Vec&lt;u8&gt;, <span class="kw-2">&amp;</span><span class="lifetime">&#39;static </span>str&gt; {}

<span class="attr">#[cfg(feature = <span class="kw">try</span>-runtime)]
</span><span class="kw">fn </span>post_upgrade(state: Vec&lt;u8&gt;) -&gt; <span class="prelude-ty">Result</span>&lt;(), <span class="kw-2">&amp;</span><span class="lifetime">&#39;static </span>str&gt; {}</code></pre></div>
<p>(The pallet macro syntax will support this simply as a part of <code>#[pallet::hooks]</code>).</p>
<p>These hooks allow you to execute some code, only within the <code>on-runtime-upgrade</code> command, before
and after the migration. Moreover, <code>pre_upgrade</code> can return a <code>Vec&lt;u8&gt;</code> that contains arbitrary
encoded data (usually some pre-upgrade state) which will be passed to <code>post_upgrade</code> after
upgrading and used for post checking.</p>
<h3 id="state-consistency"><a href="#state-consistency">State Consistency</a></h3>
<p>Similarly, each pallet can expose a function in <code>#[pallet::hooks]</code> section as follows:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#[cfg(feature = <span class="kw">try</span>-runtime)]
</span><span class="kw">fn </span>try_state(<span class="kw">_</span>) -&gt; <span class="prelude-ty">Result</span>&lt;(), <span class="kw-2">&amp;</span><span class="lifetime">&#39;static </span>str&gt; {}</code></pre></div>
<p>which is called on numerous code paths in the try-runtime tool. These checks should ensure that
the state of the pallet is consistent and correct. See <code>frame_support::try_runtime::TryState</code>
for more info.</p>
<h5 id="logging"><a href="#logging">Logging</a></h5>
<p>It is super helpful to make sure your migration code uses logging (always with a <code>runtime</code> log
target prefix, e.g. <code>runtime::balance</code>) and state exactly at which stage it is, and what it is
doing.</p>
<h5 id="guarding-migrations"><a href="#guarding-migrations">Guarding migrations</a></h5>
<p>Always make sure that any migration code is guarded either by <code>StorageVersion</code>, or by some
custom storage item, so that it is NEVER executed twice, even if the code lives in two
consecutive runtimes.</p>
<h3 id="examples"><a href="#examples">Examples</a></h3>
<p>For the following examples, we assume the existence of the following:</p>
<ol>
<li>a substrate node compiled without <code>--feature try-runtime</code>, called <code>substrate</code>. This will be
the running node that you connect to. then, after some changes to this node, you compile it with
<code>--features try-runtime</code>. This gives you:</li>
<li>a substrate binary that has the try-runtime sub-command enabled.</li>
<li>a wasm blob that has try-runtime functionality.</li>
</ol>
<div class="example-wrap"><pre class="language-bash"><code>cargo build --release &amp;&amp; cp target/release/substrate .

cargo build --release --features try-runtime
cp target/release/substrate substrate-try-runtime
cp ./target/release/wbuild/kitchensink-runtime/kitchensink_runtime.wasm runtime-try-runtime.wasm</code></pre></div>
<blockquote>
<p>The above example is with <code>substrate</code>’s <code>kitchensink-runtime</code>, but is applicable to any
substrate-based chain that has implemented <code>try-runtime-cli</code>.</p>
</blockquote>
<ul>
<li>If you run <code>try-runtime</code> subcommand against <code>substrate</code> binary listed above, you get the
following error.</li>
</ul>
<div class="example-wrap"><pre class="language-bash"><code>[substrate] ./substrate try-runtime
Error: Input(&quot;TryRuntime wasn&#39;t enabled when building the node. You can enable it with `--features try-runtime`.&quot;)</code></pre></div>
<ul>
<li>If you run the same against <code>substrate-try-runtime</code>, it will work.</li>
</ul>
<div class="example-wrap"><pre class="language-bash"><code>[substrate] ./substrate-try-runtime try-runtime
Try some command against runtime state

Usage: substrate-try-runtime try-runtime [OPTIONS] --runtime &lt;RUNTIME&gt; &lt;COMMAND&gt;

Commands:
  on-runtime-upgrade  Execute the migrations of the &quot;local runtime&quot;
  execute-block       Executes the given block against some state
  offchain-worker     Executes *the offchain worker hooks* of a given block against some state
  follow-chain        Follow the given chain&#39;s finalized blocks and apply all of its extrinsics
  create-snapshot     Create a new snapshot file
  help                Print this message or the help of the given subcommand(s)

Options:
      --chain &lt;CHAIN_SPEC&gt;
          Specify the chain specification
      --dev
          Specify the development chain
  -d, --base-path &lt;PATH&gt;
          Specify custom base path
  -l, --log &lt;LOG_PATTERN&gt;...
          Sets a custom logging filter. Syntax is `&lt;target&gt;=&lt;level&gt;`, e.g. -lsync=debug
      --detailed-log-output
          Enable detailed log output
      --disable-log-color
          Disable log color output
      --enable-log-reloading
          Enable feature to dynamically update and reload the log filter
      --tracing-targets &lt;TARGETS&gt;
          Sets a custom profiling filter. Syntax is the same as for logging: `&lt;target&gt;=&lt;level&gt;`
      --tracing-receiver &lt;RECEIVER&gt;
          Receiver to process tracing messages [default: log] [possible values: log]
      --runtime &lt;RUNTIME&gt;
          The runtime to use
      --wasm-execution &lt;METHOD&gt;
          Type of wasm execution used [default: compiled] [possible values: interpreted-i-know-what-i-do, compiled]
      --wasm-instantiation-strategy &lt;STRATEGY&gt;
          The WASM instantiation method to use [default: pooling-copy-on-write] [possible values: pooling-copy-on-write, recreate-instance-copy-on-write, pooling, recreate-instance, legacy-instance-reuse]
      --heap-pages &lt;HEAP_PAGES&gt;
          The number of 64KB pages to allocate for Wasm execution. Defaults to [`sc_service::Configuration.default_heap_pages`]
      --overwrite-state-version &lt;OVERWRITE_STATE_VERSION&gt;
          Overwrite the `state_version`
  -h, --help
          Print help information (use `--help` for more detail)
  -V, --version
          Print version information</code></pre></div>
<ul>
<li>Run the migrations of a given runtime on top of a live state.</li>
</ul>
<div class="example-wrap"><pre class="language-bash"><code>./substrate-try-runtime \
    try-runtime \
    --runtime kitchensink_runtime.wasm \
    -lruntime=debug \
    on-runtime-upgrade \
    live --uri ws://localhost:9999</code></pre></div>
<ul>
<li>Same as the previous one, but run it at specific block number’s state. This means that this
block hash’s state shall not yet have been pruned in <code>rpc.polkadot.io</code>.</li>
</ul>
<div class="example-wrap"><pre class="language-bash"><code>./substrate-try-runtime \
    try-runtime \
    --runtime kitchensink_runtime.wasm \
    -lruntime=debug \
    on-runtime-upgrade \
    live --uri ws://localhost:9999 \
    --at 0xa1b16c1efd889a9f17375ec4dd5c1b4351a2be17fa069564fced10d23b9b3836</code></pre></div>
<ul>
<li>Executing the same command with the <a href="enum.Runtime.html#variant.Existing" title="Runtime::Existing"><code>Runtime::Existing</code></a> will fail because the existing
runtime, stored onchain in <code>substrate</code> binary that we compiled earlier does not have
<code>try-runtime</code> feature!</li>
</ul>
<div class="example-wrap"><pre class="language-bash"><code>./substrate-try-runtime try-runtime --runtime existing -lruntime=debug on-runtime-upgrade live --uri ws://localhost:9999
...
Error: Input(&quot;given runtime is NOT compiled with try-runtime feature!&quot;)</code></pre></div>
<ul>
<li>Now, let’s use a snapshot file. First, we create the snapshot:</li>
</ul>
<div class="example-wrap"><pre class="language-bash"><code>./substrate-try-runtime try-runtime --runtime existing -lruntime=debug create-snapshot --uri ws://localhost:9999
2022-12-13 10:28:17.516  INFO main try-runtime::cli: snapshot path not provided (-s), using &#39;node-268@latest.snap&#39;
2022-12-13 10:28:17.516  INFO                 main remote-ext: since no at is provided, setting it to latest finalized head, 0xe7d0b614dfe89af65b33577aae46a6f958c974bf52f8a5e865a0f4faeb578d22
2022-12-13 10:28:17.516  INFO                 main remote-ext: since no prefix is filtered, the data for all pallets will be downloaded
2022-12-13 10:28:17.550  INFO                 main remote-ext: writing snapshot of 1611464 bytes to &quot;node-268@latest.snap&quot;
2022-12-13 10:28:17.551  INFO                 main remote-ext: initialized state externalities with storage root 0x925e4e95de4c08474fb7f976c4472fa9b8a1091619cd7820a793bf796ee6d932 and state_version V1</code></pre></div>
<blockquote>
<p>Note that the snapshot contains the <code>existing</code> runtime, which does not have the correct
<code>try-runtime</code> feature. In the following commands, we still need to overwrite the runtime.</p>
</blockquote>
<p>Then, we can use it to have the same command as before, <code>on-runtime-upgrade</code></p>
<div class="example-wrap"><pre class="language-bash"><code>try-runtime \
    --runtime runtime-try-runtime.wasm \
    -lruntime=debug \
    on-runtime-upgrade \
    snap -s node-268@latest.snap</code></pre></div>
<ul>
<li>Execute the latest finalized block with the given runtime.</li>
</ul>
<div class="example-wrap"><pre class="language-bash"><code>./substrate-try-runtime try-runtime \
    --runtime runtime-try-runtime.wasm \
    -lruntime=debug \
    execute-block live \
    --uri ws://localhost:999</code></pre></div>
<p>This can still be customized at a given block with <code>--at</code>. If you want to use a snapshot, you
can still use <code>--block-ws-uri</code> to provide a node form which the block data can be fetched.</p>
<p>Moreover, this runs the <code>frame_support::try_runtime::TryState</code> hooks as well. The hooks to run
can be customized with the <code>--try-state</code>. For example:</p>
<div class="example-wrap"><pre class="language-bash"><code>./substrate-try-runtime try-runtime \
    --runtime runtime-try-runtime.wasm \
    -lruntime=debug \
    execute-block live \
    --try-state System,Staking \
    --uri ws://localhost:999</code></pre></div>
<p>Will only run the <code>try-state</code> of the two given pallets. See
<a href="../frame_support/traits/try_runtime/enum.Select.html" title="frame_try_runtime::TryStateSelect"><code>frame_try_runtime::TryStateSelect</code></a> for more information.</p>
<ul>
<li>Follow our live chain’s blocks using <code>follow-chain</code>, whilst running the try-state of 3 pallets
in a round robin fashion</li>
</ul>
<div class="example-wrap"><pre class="language-bash"><code>./substrate-try-runtime \
    try-runtime \
    --runtime runtime-try-runtime.wasm \
    -lruntime=debug \
    follow-chain \
    --uri ws://localhost:9999 \
    --try-state rr-3</code></pre></div></div></details><h2 id="modules" class="small-section-header"><a href="#modules">Modules</a></h2><div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="mod" href="commands/index.html" title="try_runtime_cli::commands mod">commands</a></div></div></div><h2 id="structs" class="small-section-header"><a href="#structs">Structs</a></h2><div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.LiveState.html" title="try_runtime_cli::LiveState struct">LiveState</a></div><div class="item-right docblock-short">A <code>Live</code> variant <a href="enum.State.html" title="State"><code>State</code></a></div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.SharedParams.html" title="try_runtime_cli::SharedParams struct">SharedParams</a></div><div class="item-right docblock-short">Shared parameters of the <code>try-runtime</code> commands</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.TryRuntimeCmd.html" title="try_runtime_cli::TryRuntimeCmd struct">TryRuntimeCmd</a></div><div class="item-right docblock-short">Our <code>try-runtime</code> command.</div></div></div><h2 id="enums" class="small-section-header"><a href="#enums">Enums</a></h2><div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="enum" href="enum.Command.html" title="try_runtime_cli::Command enum">Command</a></div><div class="item-right docblock-short">Possible commands of <code>try-runtime</code>.</div></div><div class="item-row"><div class="item-left module-item"><a class="enum" href="enum.Runtime.html" title="try_runtime_cli::Runtime enum">Runtime</a></div></div><div class="item-row"><div class="item-left module-item"><a class="enum" href="enum.State.html" title="try_runtime_cli::State enum">State</a></div><div class="item-right docblock-short">The source of runtime <em>state</em> to use.</div></div></div></section></div></main><div id="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="try_runtime_cli" data-themes="" data-resource-suffix="" data-rustdoc-version="1.67.0-nightly (a00f8ba7f 2022-11-15)" data-search-js="search-df80cc3cb87b6482.js" data-settings-js="settings-7873449fa8c00e11.js" data-settings-css="settings-af96d9e2fc13e081.css" ></div></body></html>