<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Try-runtime"><title>try_runtime_cli - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceSerif4-Bold-a2c9cd1067f8b328.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2"><link rel="stylesheet" href="../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../static.files/rustdoc-c4dbdcde0fbd8430.css" id="mainThemeStyle"><link rel="stylesheet" id="themeStyle" href="../static.files/light-db279b6232be9c13.css"><link rel="stylesheet" disabled href="../static.files/dark-cf923f49f397b216.css"><link rel="stylesheet" disabled href="../static.files/ayu-be46fdc453a55015.css"><script src="../static.files/storage-3891ce972e3a2bf8.js"></script><script defer src="../crates.js"></script><script defer src="../static.files/main-98a684e84ae5b08b.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-13285aec31fa243e.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-16x16-8b506e7a72182f1c.png"><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="logo-container" href="../try_runtime_cli/index.html"><img class="rust-logo" src="../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2></h2></nav><nav class="sidebar"><a class="logo-container" href="../try_runtime_cli/index.html"><img class="rust-logo" src="../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2 class="location"><a href="#">Crate try_runtime_cli</a></h2><div class="sidebar-elems"><ul class="block"><li class="version">Version 0.10.0-dev</li><li><a id="all-types" href="all.html">All Items</a></li></ul><section><ul class="block"><li><a href="#modules">Modules</a></li><li><a href="#structs">Structs</a></li><li><a href="#enums">Enums</a></li></ul></section></div></nav><main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" title="help" tabindex="-1"><a href="../help.html">?</a></div><div id="settings-menu" tabindex="-1"><a href="../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../static.files/wheel-7b819b6101059cd0.svg"></a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1>Crate <a class="mod" href="#">try_runtime_cli</a><button id="copy-path" title="Copy item path to clipboard"><img src="../static.files/clipboard-7571035ce49a181d.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><a class="srclink" href="../src/try_runtime_cli/lib.rs.html#18-1023">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><h2 id="try-runtime"><a href="#try-runtime">Try-runtime</a></h2>
<p>Substrate’s ultimate testing framework for the power users.</p>
<blockquote>
<p>As the name suggests, <code>try-runtime</code> is a detailed testing framework that gives you a lot of
control over what is being executed in which environment. It is recommended that user’s first
familiarize themselves with substrate in depth, particularly the execution model. It is critical
to deeply understand how the wasm/client/runtime interactions, and the runtime apis work in the
substrate runtime, before commencing to working with <code>try-runtime</code>.</p>
</blockquote>
<h5 id="resources"><a href="#resources">Resources</a></h5>
<p>Some resources about the above:</p>
<ol>
<li><a href="https://docs.substrate.io/reference/command-line-tools/try-runtime/">https://docs.substrate.io/reference/command-line-tools/try-runtime/</a></li>
<li><a href="https://www.crowdcast.io/e/substrate-seminar/41">https://www.crowdcast.io/e/substrate-seminar/41</a></li>
<li><a href="https://docs.substrate.io/fundamentals/runtime-development/">https://docs.substrate.io/fundamentals/runtime-development/</a></li>
</ol>
<hr />
<h3 id="background-knowledge"><a href="#background-knowledge">Background Knowledge</a></h3>
<p>The basis of all try-runtime commands is the same: connect to a live node, scrape its <em>state</em>
and put it inside a <code>TestExternalities</code>, then call into a <em>specific runtime-api</em> using the given
state and some <em>runtime</em>.</p>
<p>Alternatively, the state could come from a snapshot file.</p>
<p>All of the variables in the above statement are made <em>italic</em>. Let’s look at each of them:</p>
<ol>
<li>
<p><strong>State</strong> is the key-value pairs of data that comprise the canonical information that any
blockchain is keeping. A state can be full (all key-value pairs), or be partial (only pairs
related to some pallets/prefixes). Moreover, some keys are especial and are not related to
specific pallets, known as <a href="../sp_storage/well_known_keys/index.html" title="mod sp_storage::well_known_keys"><code>well_known_keys</code></a> in substrate. The most important of these is
the <code>:CODE:</code> key, which contains the code used for execution, when wasm execution is chosen.</p>
</li>
<li>
<p><em>A runtime-api</em> call is a call into a function defined in the runtime, <em>on top of a given
state</em>. Each subcommand of <code>try-runtime</code> utilizes a specific <em>runtime-api</em>.</p>
</li>
<li>
<p>Finally, the <strong>runtime</strong> is the actual code that is used to execute the aforementioned
runtime-api. Everything in this crate assumes wasm execution, which means the runtime that
you use is the one stored onchain, namely under the <code>:CODE:</code> key.</p>
</li>
</ol>
<p>To recap, a typical try-runtime command does the following:</p>
<ol>
<li>Download the state of a live chain, and write to an <code>externalities</code>.</li>
<li>Overwrite the <code>:CODE:</code> with a given wasm blob</li>
<li>Test some functionality via calling a runtime-api.</li>
</ol>
<h3 id="usage"><a href="#usage">Usage</a></h3>
<p>To use any of the provided commands, <a href="struct.SharedParams.html" title="struct try_runtime_cli::SharedParams"><code>SharedParams</code></a> must be provided. The most important of
which being <a href="struct.SharedParams.html#structfield.runtime" title="field try_runtime_cli::SharedParams::runtime"><code>SharedParams::runtime</code></a>, which specifies which runtime to use. Furthermore,
<a href="struct.SharedParams.html#structfield.overwrite_state_version" title="field try_runtime_cli::SharedParams::overwrite_state_version"><code>SharedParams::overwrite_state_version</code></a> can be used to alter the state-version (see
<a href="https://forum.polkadot.network/t/state-trie-migration/852">https://forum.polkadot.network/t/state-trie-migration/852</a> for more info).</p>
<p>Then, the specific command has to be specified. See <a href="enum.Command.html" title="enum try_runtime_cli::Command"><code>Command</code></a> for more information about each
command’s specific customization flags, and assumptions regarding the runtime being used.</p>
<p>Said briefly, this CLI is capable of executing:</p>
<ul>
<li><a href="enum.Command.html#variant.OnRuntimeUpgrade" title="variant try_runtime_cli::Command::OnRuntimeUpgrade"><code>Command::OnRuntimeUpgrade</code></a>: execute all the <code>on_runtime_upgrade</code> hooks.</li>
<li><a href="enum.Command.html#variant.ExecuteBlock" title="variant try_runtime_cli::Command::ExecuteBlock"><code>Command::ExecuteBlock</code></a>: re-execute the given block.</li>
<li><a href="enum.Command.html#variant.OffchainWorker" title="variant try_runtime_cli::Command::OffchainWorker"><code>Command::OffchainWorker</code></a>: re-execute the given block’s offchain worker code path.</li>
<li><a href="enum.Command.html#variant.FollowChain" title="variant try_runtime_cli::Command::FollowChain"><code>Command::FollowChain</code></a>: continuously execute the blocks of a remote chain on top of a given
runtime.</li>
<li><a href="enum.Command.html#variant.CreateSnapshot" title="variant try_runtime_cli::Command::CreateSnapshot"><code>Command::CreateSnapshot</code></a>: Create a snapshot file from a remote node.</li>
</ul>
<p>Finally, To make sure there are no errors regarding this, always run any <code>try-runtime</code> command
with <code>executor=trace</code> logging targets, which will specify which runtime is being used per api
call. Moreover, <code>remote-ext</code>, <code>try-runtime</code> and <code>runtime</code> logs targets will also be useful.</p>
<h3 id="spec-name-check"><a href="#spec-name-check">Spec name check</a></h3>
<p>A common pitfall is that you might be running some test on top of the state of chain <code>x</code>, with
the runtime of chain <code>y</code>. To avoid this all commands do a spec-name check before executing
anything by default. This will check the, if any alterations are being made to the <code>:CODE:</code>,
then the spec names match. The spec versions are warned, but are not mandated to match.</p>
<blockquote>
<p>If anything, in most cases, we expect spec-versions to NOT match, because try-runtime is all
about testing unreleased runtimes.</p>
</blockquote>
<h3 id="note-on-signature-and-state-root-checks"><a href="#note-on-signature-and-state-root-checks">Note on signature and state-root checks</a></h3>
<p>All of the commands calling into <code>TryRuntime_execute_block</code> (<a href="enum.Command.html#variant.ExecuteBlock" title="variant try_runtime_cli::Command::ExecuteBlock"><code>Command::ExecuteBlock</code></a> and
<a href="enum.Command.html#variant.FollowChain" title="variant try_runtime_cli::Command::FollowChain"><code>Command::FollowChain</code></a>) disable both state root and signature checks. This is because in 99%
of the cases, the runtime that is being tested is different from the one that is stored in the
canonical chain state. This implies:</p>
<ol>
<li>the state root will NEVER match, because <code>:CODE:</code> is different between the two.</li>
<li>replaying all transactions will fail, because the spec-version is part of the transaction
signature.</li>
</ol>
<h3 id="best-practices"><a href="#best-practices">Best Practices</a></h3>
<p>Try-runtime is all about battle-testing unreleased runtime. The following list of suggestions
help developers maximize the testing coverage and make base use of <code>try-runtime</code>.</p>
<h5 id="adding-prepost-hooks"><a href="#adding-prepost-hooks">Adding pre/post hooks</a></h5>
<p>One of the gems that come only in the <code>try-runtime</code> feature flag is the <code>pre_upgrade</code> and
<code>post_upgrade</code> hooks for <code>OnRuntimeUpgrade</code>. This trait is implemented either inside the pallet,
or manually in a runtime, to define a migration. In both cases, these functions can be added,
given the right flag:</p>

<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">ⓘ</a><pre class="rust rust-example-rendered"><code><span class="attr">#[cfg(feature = <span class="string">&quot;try-runtime&quot;</span>)]
</span><span class="kw">fn </span>pre_upgrade() -&gt; <span class="prelude-ty">Result</span>&lt;Vec&lt;u8&gt;, TryRuntimeError&gt; {}

<span class="attr">#[cfg(feature = <span class="string">&quot;try-runtime&quot;</span>)]
</span><span class="kw">fn </span>post_upgrade(state: Vec&lt;u8&gt;) -&gt; <span class="prelude-ty">Result</span>&lt;(), TryRuntimeError&gt; {}</code></pre></div>
<p>(The pallet macro syntax will support this simply as a part of <code>#[pallet::hooks]</code>).</p>
<p>These hooks allow you to execute some code, only within the <code>on-runtime-upgrade</code> command, before
and after the migration. Moreover, <code>pre_upgrade</code> can return a <code>Vec&lt;u8&gt;</code> that contains arbitrary
encoded data (usually some pre-upgrade state) which will be passed to <code>post_upgrade</code> after
upgrading and used for post checking.</p>
<h3 id="state-consistency"><a href="#state-consistency">State Consistency</a></h3>
<p>Similarly, each pallet can expose a function in <code>#[pallet::hooks]</code> section as follows:</p>

<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">ⓘ</a><pre class="rust rust-example-rendered"><code><span class="attr">#[cfg(feature = <span class="string">&quot;try-runtime&quot;</span>)]
</span><span class="kw">fn </span>try_state(<span class="kw">_</span>: BlockNumber) -&gt; <span class="prelude-ty">Result</span>&lt;(), TryRuntimeError&gt; {}</code></pre></div>
<p>which is called on numerous code paths in the try-runtime tool. These checks should ensure that
the state of the pallet is consistent and correct. See <code>frame_support::try_runtime::TryState</code>
for more info.</p>
<h5 id="logging"><a href="#logging">Logging</a></h5>
<p>It is super helpful to make sure your migration code uses logging (always with a <code>runtime</code> log
target prefix, e.g. <code>runtime::balance</code>) and state exactly at which stage it is, and what it is
doing.</p>
<h5 id="guarding-migrations"><a href="#guarding-migrations">Guarding migrations</a></h5>
<p>Always make sure that any migration code is guarded either by <code>StorageVersion</code>, or by some
custom storage item, so that it is NEVER executed twice, even if the code lives in two
consecutive runtimes.</p>
<h3 id="examples"><a href="#examples">Examples</a></h3>
<p>For the following examples, we assume the existence of the following:</p>
<ol>
<li>a substrate node compiled without <code>--feature try-runtime</code>, called <code>substrate</code>. This will be
the running node that you connect to. then, after some changes to this node, you compile it with
<code>--features try-runtime</code>. This gives you:</li>
<li>a substrate binary that has the try-runtime sub-command enabled.</li>
<li>a wasm blob that has try-runtime functionality.</li>
</ol>
<div class="example-wrap"><pre class="language-bash"><code># this is like your running deployed node.
cargo build --release &amp;&amp; cp target/release/substrate .

# this is like your WIP branch.
cargo build --release --features try-runtime
cp target/release/substrate substrate-try-runtime
cp ./target/release/wbuild/kitchensink-runtime/kitchensink_runtime.wasm runtime-try-runtime.wasm
</code></pre></div>
<blockquote>
<p>The above example is with <code>substrate</code>’s <code>kitchensink-runtime</code>, but is applicable to any
substrate-based chain that has implemented <code>try-runtime-cli</code>.</p>
</blockquote>
<ul>
<li>If you run <code>try-runtime</code> subcommand against <code>substrate</code> binary listed above, you get the
following error.</li>
</ul>
<div class="example-wrap"><pre class="language-bash"><code>[substrate] ./substrate try-runtime
Error: Input(&quot;TryRuntime wasn&#39;t enabled when building the node. You can enable it with `--features try-runtime`.&quot;)
</code></pre></div>
<ul>
<li>If you run the same against <code>substrate-try-runtime</code>, it will work.</li>
</ul>
<div class="example-wrap"><pre class="language-bash"><code>[substrate] ./substrate-try-runtime try-runtime
Try some command against runtime state

Usage: substrate-try-runtime try-runtime [OPTIONS] --runtime &lt;RUNTIME&gt; &lt;COMMAND&gt;

Commands:
  on-runtime-upgrade  Execute the migrations of the &quot;local runtime&quot;
  execute-block       Executes the given block against some state
  offchain-worker     Executes *the offchain worker hooks* of a given block against some state
  follow-chain        Follow the given chain&#39;s finalized blocks and apply all of its extrinsics
  create-snapshot     Create a new snapshot file
  help                Print this message or the help of the given subcommand(s)

Options:
      --chain &lt;CHAIN_SPEC&gt;
          Specify the chain specification
      --dev
          Specify the development chain
  -d, --base-path &lt;PATH&gt;
          Specify custom base path
  -l, --log &lt;LOG_PATTERN&gt;...
          Sets a custom logging filter. Syntax is `&lt;target&gt;=&lt;level&gt;`, e.g. -lsync=debug
      --detailed-log-output
          Enable detailed log output
      --disable-log-color
          Disable log color output
      --enable-log-reloading
          Enable feature to dynamically update and reload the log filter
      --tracing-targets &lt;TARGETS&gt;
          Sets a custom profiling filter. Syntax is the same as for logging: `&lt;target&gt;=&lt;level&gt;`
      --tracing-receiver &lt;RECEIVER&gt;
          Receiver to process tracing messages [default: log] [possible values: log]
      --runtime &lt;RUNTIME&gt;
          The runtime to use
      --wasm-execution &lt;METHOD&gt;
          Type of wasm execution used [default: compiled] [possible values: interpreted-i-know-what-i-do, compiled]
      --wasm-instantiation-strategy &lt;STRATEGY&gt;
          The WASM instantiation method to use [default: pooling-copy-on-write] [possible values: pooling-copy-on-write, recreate-instance-copy-on-write, pooling, recreate-instance, legacy-instance-reuse]
      --heap-pages &lt;HEAP_PAGES&gt;
          The number of 64KB pages to allocate for Wasm execution. Defaults to [`sc_service::Configuration.default_heap_pages`]
      --overwrite-state-version &lt;OVERWRITE_STATE_VERSION&gt;
          Overwrite the `state_version`
  -h, --help
          Print help information (use `--help` for more detail)
  -V, --version
          Print version information
</code></pre></div>
<ul>
<li>Run the migrations of a given runtime on top of a live state.</li>
</ul>
<div class="example-wrap"><pre class="language-bash"><code># assuming there&#39;s `./substrate --dev --tmp --ws-port 9999` or similar running.
./substrate-try-runtime \
    try-runtime \
    --runtime runtime-try-runtime.wasm \
    -lruntime=debug \
    on-runtime-upgrade \
    live --uri ws://localhost:9999
</code></pre></div>
<ul>
<li>Same as the previous one, but run it at specific block number’s state. This means that this
block hash’s state shall not yet have been pruned in <code>rpc.polkadot.io</code>.</li>
</ul>
<div class="example-wrap"><pre class="language-bash"><code>./substrate-try-runtime \
    try-runtime \
    --runtime runtime-try-runtime.wasm \
    -lruntime=debug \
    on-runtime-upgrade \
    live --uri ws://localhost:9999 \
    # replace with your desired block hash!
    --at 0xa1b16c1efd889a9f17375ec4dd5c1b4351a2be17fa069564fced10d23b9b3836
</code></pre></div>
<ul>
<li>Executing the same command with the <a href="enum.Runtime.html#variant.Existing" title="variant try_runtime_cli::Runtime::Existing"><code>Runtime::Existing</code></a> will fail because the existing
runtime, stored onchain in <code>substrate</code> binary that we compiled earlier does not have
<code>try-runtime</code> feature!</li>
</ul>
<div class="example-wrap"><pre class="language-bash"><code>./substrate-try-runtime try-runtime --runtime existing -lruntime=debug on-runtime-upgrade live --uri ws://localhost:9999
...
Error: Input(&quot;given runtime is NOT compiled with try-runtime feature!&quot;)
</code></pre></div>
<ul>
<li>Now, let’s use a snapshot file. First, we create the snapshot:</li>
</ul>
<div class="example-wrap"><pre class="language-bash"><code>./substrate-try-runtime try-runtime --runtime existing -lruntime=debug create-snapshot --uri ws://localhost:9999
2022-12-13 10:28:17.516  INFO main try-runtime::cli: snapshot path not provided (-s), using &#39;node-268@latest.snap&#39;
2022-12-13 10:28:17.516  INFO                 main remote-ext: since no at is provided, setting it to latest finalized head, 0xe7d0b614dfe89af65b33577aae46a6f958c974bf52f8a5e865a0f4faeb578d22
2022-12-13 10:28:17.516  INFO                 main remote-ext: since no prefix is filtered, the data for all pallets will be downloaded
2022-12-13 10:28:17.550  INFO                 main remote-ext: writing snapshot of 1611464 bytes to &quot;node-268@latest.snap&quot;
2022-12-13 10:28:17.551  INFO                 main remote-ext: initialized state externalities with storage root 0x925e4e95de4c08474fb7f976c4472fa9b8a1091619cd7820a793bf796ee6d932 and state_version V1
</code></pre></div>
<blockquote>
<p>Note that the snapshot contains the <code>existing</code> runtime, which does not have the correct
<code>try-runtime</code> feature. In the following commands, we still need to overwrite the runtime.</p>
</blockquote>
<p>Then, we can use it to have the same command as before, <code>on-runtime-upgrade</code></p>
<div class="example-wrap"><pre class="language-bash"><code>./substrate-try-runtime try-runtime \
    --runtime runtime-try-runtime.wasm \
    -lruntime=debug \
    on-runtime-upgrade \
    snap -s node-268@latest.snap
</code></pre></div>
<ul>
<li>Execute the latest finalized block with the given runtime.</li>
</ul>
<div class="example-wrap"><pre class="language-bash"><code>./substrate-try-runtime try-runtime \
    --runtime runtime-try-runtime.wasm \
    -lruntime=debug \
    execute-block live \
    --uri ws://localhost:9999
</code></pre></div>
<p>This can still be customized at a given block with <code>--at</code>. If you want to use a snapshot, you
can still use <code>--block-ws-uri</code> to provide a node form which the block data can be fetched.</p>
<p>Moreover, this runs the <code>frame_support::try_runtime::TryState</code> hooks as well. The hooks to run
can be customized with the <code>--try-state</code>. For example:</p>
<div class="example-wrap"><pre class="language-bash"><code>./substrate-try-runtime try-runtime \
   --runtime runtime-try-runtime.wasm \
   -lruntime=debug \
   execute-block \
   --try-state System,Staking \
   live \
   --uri ws://localhost:9999 \
   --pallet System Staking
</code></pre></div>
<p>Will only run the <code>try-state</code> of the two given pallets. When running <code>try-state</code> against
some real chain data it can take a long time for the command to execute since it has to
query all the key-value pairs. In scenarios like above where we only want to run the
<code>try-state</code> for some specific pallets, we can use the <code>--pallet</code> option to specify from
which pallets we want to query the state. This will greatly decrease the execution time.</p>
<p>See <a href="../frame_support/traits/try_runtime/enum.Select.html" title="enum frame_support::traits::try_runtime::Select"><code>frame_try_runtime::TryStateSelect</code></a> for more information.</p>
<ul>
<li>Follow our live chain’s blocks using <code>follow-chain</code>, whilst running the try-state of 3 pallets
in a round robin fashion</li>
</ul>
<div class="example-wrap"><pre class="language-bash"><code>./substrate-try-runtime \
    try-runtime \
    --runtime runtime-try-runtime.wasm \
    -lruntime=debug \
    follow-chain \
    --uri ws://localhost:9999 \
    --try-state rr-3
</code></pre></div></div></details><h2 id="modules" class="small-section-header"><a href="#modules">Modules</a></h2><ul class="item-table"><li><div class="item-name"><a class="mod" href="block_building_info/index.html" title="mod try_runtime_cli::block_building_info">block_building_info</a></div></li><li><div class="item-name"><a class="mod" href="commands/index.html" title="mod try_runtime_cli::commands">commands</a></div></li></ul><h2 id="structs" class="small-section-header"><a href="#structs">Structs</a></h2><ul class="item-table"><li><div class="item-name"><a class="struct" href="struct.LiveState.html" title="struct try_runtime_cli::LiveState">LiveState</a></div><div class="desc docblock-short">A <code>Live</code> variant <a href="enum.State.html" title="enum try_runtime_cli::State"><code>State</code></a></div></li><li><div class="item-name"><a class="struct" href="struct.SharedParams.html" title="struct try_runtime_cli::SharedParams">SharedParams</a></div><div class="desc docblock-short">Shared parameters of the <code>try-runtime</code> commands</div></li><li><div class="item-name"><a class="struct" href="struct.TryRuntimeCmd.html" title="struct try_runtime_cli::TryRuntimeCmd">TryRuntimeCmd</a></div><div class="desc docblock-short">Our <code>try-runtime</code> command.</div></li></ul><h2 id="enums" class="small-section-header"><a href="#enums">Enums</a></h2><ul class="item-table"><li><div class="item-name"><a class="enum" href="enum.Command.html" title="enum try_runtime_cli::Command">Command</a></div><div class="desc docblock-short">Possible commands of <code>try-runtime</code>.</div></li><li><div class="item-name"><a class="enum" href="enum.Runtime.html" title="enum try_runtime_cli::Runtime">Runtime</a></div></li><li><div class="item-name"><a class="enum" href="enum.State.html" title="enum try_runtime_cli::State">State</a></div><div class="desc docblock-short">The source of runtime <em>state</em> to use.</div></li></ul></section></div></main><div id="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="try_runtime_cli" data-themes="" data-resource-suffix="" data-rustdoc-version="1.69.0 (84c898d65 2023-04-16)" data-search-js="search-8a59a8356673ec1f.js" data-settings-js="settings-f0c5c39777a9a2f6.js" data-settings-css="settings-0bcba95ff279c1db.css" ></div></body></html>