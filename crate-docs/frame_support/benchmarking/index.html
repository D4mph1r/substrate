<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Contains macros, structs, and traits associated with v2 of the pallet benchmarking syntax. This module contains macros, structs, and traits associated with v2 of the pallet benchmarking syntax."><meta name="keywords" content="rust, rustlang, rust-lang, benchmarking"><title>frame_support::benchmarking - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/SourceSerif4-Regular-1f7d512b176f0f72.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/SourceSerif4-Bold-124a1ca42af929b6.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2"><link rel="stylesheet" href="../../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../../static.files/rustdoc-3dd8914bdd6e2ce5.css" id="mainThemeStyle"><link rel="stylesheet" id="themeStyle" href="../../static.files/light-1469fca9efc07bcb.css"><link rel="stylesheet" disabled href="../../static.files/dark-e9b7e5d8ba0dc980.css"><link rel="stylesheet" disabled href="../../static.files/ayu-0c1cf144240c9f40.css"><script id="default-settings" ></script><script src="../../static.files/storage-d43fa987303ecbbb.js"></script><script defer src="../../static.files/main-799a64abec831f72.js"></script><noscript><link rel="stylesheet" href="../../static.files/noscript-13285aec31fa243e.css"></noscript><link rel="alternate icon" type="image/png" href="../../static.files/favicon-16x16-8b506e7a72182f1c.png"><link rel="alternate icon" type="image/png" href="../../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc mod"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="sidebar-logo" href="../../frame_support/index.html"><div class="logo-container"><img class="rust-logo" src="../../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></div></a><h2></h2></nav><nav class="sidebar"><a class="sidebar-logo" href="../../frame_support/index.html"><div class="logo-container"><img class="rust-logo" src="../../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></div></a><h2 class="location"><a href="#">Module benchmarking</a></h2><div class="sidebar-elems"><section><ul class="block"><li><a href="#structs">Structs</a></li><li><a href="#traits">Traits</a></li><li><a href="#attributes">Attribute Macros</a></li></ul></section></div></nav><main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><input class="search-input" name="search" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" title="help" tabindex="-1"><a href="../../help.html">?</a></div><div id="settings-menu" tabindex="-1"><a href="../../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../../static.files/wheel-5ec35bf9ca753509.svg"></a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1 class="fqn">Module <a href="../index.html">frame_support</a>::<wbr><a class="mod" href="#">benchmarking</a><button id="copy-path" onclick="copy_path(this)" title="Copy item path to clipboard"><img src="../../static.files/clipboard-7571035ce49a181d.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><a class="srclink" href="../../src/frame_support/lib.rs.html#2929">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><details class="rustdoc-toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Contains macros, structs, and traits associated with v2 of the pallet benchmarking syntax.
This module contains macros, structs, and traits associated with v2 of the pallet
benchmarking syntax.</p>
<p>The <a href="attr.benchmarks.html" title="benchmarking::benchmarks"><code>benchmarking::benchmarks</code></a> and <a href="attr.instance_benchmarks.html" title="benchmarking::instance_benchmarks"><code>benchmarking::instance_benchmarks</code></a> macros can be
used to designate a module as a benchmarking module that can contain benchmarks and
benchmark tests. The <code>#[benchmarks]</code> variant will set up a regular, non-instance
benchmarking module, and the <code>#[instance_benchmarks]</code> variant will set up the module in
instance benchmarking mode.</p>
<p>Benchmarking modules should be gated behind a <code>#[cfg(feature = &quot;runtime-benchmarks&quot;)]</code>
feature gate to ensure benchmarking code that is only compiled when the
<code>runtime-benchmarks</code> feature is enabled is not referenced.</p>
<p>The following is the general syntax for a benchmarks (or instance benchmarks) module:</p>
<h3 id="general-syntax"><a href="#general-syntax">General Syntax</a></h3>
<div class="example-wrap ignore"><div class='tooltip'>ⓘ</div><pre class="rust rust-example-rendered"><code><span class="attr">#![cfg(feature = <span class="string">&quot;runtime-benchmarks&quot;</span>)]

</span><span class="kw">use super</span>::{mock_helpers::<span class="kw-2">*</span>, Pallet <span class="kw">as </span>MyPallet};
<span class="kw">use </span>frame_support::benchmarking::<span class="kw-2">*</span>;
<span class="kw">use </span>frame_benchmarking::whitelisted_caller;

<span class="attr">#[benchmarks]
</span><span class="kw">mod </span>benchmarks {
	<span class="kw">use super</span>::<span class="kw-2">*</span>;

	<span class="attr">#[benchmark]
	</span><span class="kw">fn </span>bench_name_1(x: Linear&lt;<span class="number">7</span>, <span class="number">1_000</span>&gt;, y: Linear&lt;<span class="number">1_000</span>, <span class="number">100_0000</span>&gt;) {
		<span class="comment">// setup code
		</span><span class="kw">let </span>z = x + y;
		<span class="kw">let </span>caller = whitelisted_caller();

		<span class="attr">#[extrinsic_call]
		</span>extrinsic_name(SystemOrigin::Signed(caller), other, arguments);

		<span class="comment">// verification code
		</span><span class="macro">assert_eq!</span>(MyPallet::&lt;T&gt;::my_var(), z);
	}

	<span class="attr">#[benchmark]
	</span><span class="kw">fn </span>bench_name_2() {
		<span class="comment">// setup code
		</span><span class="kw">let </span>caller = whitelisted_caller();

		<span class="attr">#[block]
		</span>{
			something(some, thing);
			my_extrinsic(RawOrigin::Signed(caller), some, argument);
			something_else(foo, bar);
		}

		<span class="comment">// verification code
		</span><span class="macro">assert_eq!</span>(MyPallet::&lt;T&gt;::something(), <span class="number">37</span>);
	}
}</code></pre></div>
<h3 id="benchmark-definitions"><a href="#benchmark-definitions">Benchmark Definitions</a></h3>
<p>Within a <code>#[benchmarks]</code> or <code>#[instance_benchmarks]</code> module, you can define individual
benchmarks using the <code>#[benchmark]</code> attribute, as shown in the example above.</p>
<p>The <code>#[benchmark]</code> attribute expects a function definition with a blank return type and
zero or more arguments whose names are valid <code>frame_benchmarking::BenchmarkParamater</code>
parameters, such as <code>x</code>, <code>y</code>, <code>a</code>, <code>b</code>, etc., and whose param types must implement
<a href="trait.ParamRange.html" title="benchmarking::ParamRange"><code>benchmarking::ParamRange</code></a>. At the moment the only valid type that implements
<a href="trait.ParamRange.html" title="benchmarking::ParamRange"><code>benchmarking::ParamRange</code></a> is <a href="struct.Linear.html" title="benchmarking::Linear"><code>benchmarking::Linear</code></a>.</p>
<p>The valid syntax for defining a <code>Linear</code> is <code>Linear&lt;A, B&gt;</code> where <code>A</code>, and <code>B</code> are
valid integer literals (that fit in a <code>u32</code>), such that <code>B</code> &gt;= <code>A</code>.</p>
<p>Note that the benchmark function definition does not actually expand as a function
definition, but rather is used to automatically create a number of impls and structs
required by the benchmarking engine. For this reason, the visibility of the function
definition as well as the return type are not used for any purpose and are discarded by the
expansion code.</p>
<p>Also note that the <code>// setup code</code> and <code>// verification code</code> comments shown above are not
required and are included simply for demonstration purposes.</p>
<h4 id="extrinsic_call-and-block"><a href="#extrinsic_call-and-block"><code>#[extrinsic_call]</code> and <code>#[block]</code></a></h4>
<p>Within the benchmark function body, either an <code>#[extrinsic_call]</code> or a <code>#[block]</code>
annotation is required. These attributes should be attached to a block (shown in
<code>bench_name_2</code> above) or a one-line function call (shown in <code>bench_name_1</code> above, in <code>syn</code>
parlance this should be an <code>ExprCall</code>), respectively.</p>
<p>The <code>#[block]</code> syntax is broad and will benchmark any code contained within the block the
attribute is attached to. If <code>#[block]</code> is attached to something other than a block, a
compiler error will be emitted.</p>
<p>The one-line <code>#[extrinsic_call]</code> syntax must consist of a function call to an extrinsic,
where the first argument is the origin. If <code>#[extrinsic_call]</code> is attached to an item that
doesn’t meet these requirements, a compiler error will be emitted.</p>
<p>As a short-hand, you may substitute the name of the extrinsic call with <code>_</code>, such as the
following:</p>

<div class="example-wrap ignore"><div class='tooltip'>ⓘ</div><pre class="rust rust-example-rendered"><code>	<span class="attr">#[extrinsic_call]
</span><span class="kw">_</span>(RawOrigin::Signed(whitelisted_caller()), <span class="number">0u32</span>.into(), <span class="number">0</span>);</code></pre></div>
<p>The underscore will be substituted with the name of the benchmark  (i.e. the name of the
function in the benchmark function definition).</p>
<p>Regardless of whether <code>#[extrinsic_call]</code> or <code>#[block]</code> is used, this attribute also serves
the purpose of designating the boundary between the setup code portion of the benchmark
(everything before the <code>#[extrinsic_call]</code> or <code>#[block]</code> attribute) and the verification
stage (everything after the item that the <code>#[extrinsic_call]</code> or <code>#[block]</code> attribute is
attached to). The setup code section should contain any code that needs to execute before
the measured portion of the benchmark executes. The verification section is where you can
perform assertions to verify that the extrinsic call (or whatever is happening in your
block, if you used the <code>#[block]</code> syntax) executed successfully.</p>
<p>Note that neither <code>#[extrinsic_call]</code> nor <code>#[block]</code> are real attribute macros and are
instead consumed by the outer macro pattern as part of the enclosing benchmark function
definition. This is why we are able to use <code>#[extrinsic_call]</code> and <code>#[block]</code> within a
function definition even though this behavior has not been stabilized
yet—<code>#[extrinsic_call]</code> and <code>#[block]</code> are parsed and consumed as part of the benchmark
definition parsing code, so they never expand as their own attribute macros.</p>
<h4 id="optional-attributes"><a href="#optional-attributes">Optional Attributes</a></h4>
<p>The keywords <code>extra</code> and <code>skip_meta</code> can be provided as optional arguments to the
<code>#[benchmark]</code> attribute, i.e. <code>#[benchmark(extra, skip_meta)]</code>. Including either of these
will enable the <code>extra</code> or <code>skip_meta</code> option, respectively. These options enable the same
behavior they did in the old benchmarking syntax in <code>frame_benchmarking</code>, namely:</p>
<h5 id="extra"><a href="#extra"><code>extra</code></a></h5>
<p>Specifies that this benchmark should not normally run. To run benchmarks marked with
<code>extra</code>, you will need to invoke the <code>frame-benchmarking-cli</code> with <code>--extra</code>.</p>
<h5 id="skip_meta"><a href="#skip_meta"><code>skip_meta</code></a></h5>
<p>Specifies that the benchmarking framework should not analyze the storage keys that
benchmarked code read or wrote. This useful to suppress the prints in the form of unknown
0x… in case a storage key that does not have metadata. Note that this skips the analysis
of all accesses, not just ones without metadata.</p>
<h3 id="where-clause"><a href="#where-clause">Where Clause</a></h3>
<p>Some pallets require a where clause specifying constraints on their generics to make
writing benchmarks feasible. To accomodate this situation, you can provide such a where
clause as the (only) argument to the <code>#[benchmarks]</code> or <code>#[instance_benchmarks]</code> attribute
macros. Below is an example of this taken from the <code>message-queue</code> pallet.</p>

<div class="example-wrap ignore"><div class='tooltip'>ⓘ</div><pre class="rust rust-example-rendered"><code><span class="attr">#[benchmarks(
	<span class="kw">where
		</span>&lt;&lt;T <span class="kw">as </span>Config&gt;::MessageProcessor <span class="kw">as </span>ProcessMessage&gt;::Origin: From&lt;u32&gt; + PartialEq,
		&lt;T <span class="kw">as </span>Config&gt;::Size: From&lt;u32&gt;,
)]
</span><span class="kw">mod </span>benchmarks {
	<span class="kw">use super</span>::<span class="kw-2">*</span>;
	<span class="comment">// ...
</span>}</code></pre></div>
<h3 id="benchmark-tests"><a href="#benchmark-tests">Benchmark Tests</a></h3>
<p>Benchmark tests can be generated using the old syntax in <code>frame_benchmarking</code>,
including the <code>frame_benchmarking::impl_benchmark_test_suite</code> macro.</p>
<p>An example is shown below (taken from the <code>message-queue</code> pallet’s <code>benchmarking</code> module):</p>

<div class="example-wrap ignore"><div class='tooltip'>ⓘ</div><pre class="rust rust-example-rendered"><code><span class="attr">#[benchmarks]
</span><span class="kw">mod </span>benchmarks {
	<span class="kw">use super</span>::<span class="kw-2">*</span>;
	<span class="comment">// ...
	</span><span class="macro">impl_benchmark_test_suite!</span>(
		MessageQueue,
		<span class="kw">crate</span>::mock::new_test_ext::&lt;<span class="kw">crate</span>::integration_test::Test&gt;(),
		<span class="kw">crate</span>::integration_test::Test
	);
}</code></pre></div>
</div></details><h2 id="structs" class="small-section-header"><a href="#structs">Structs</a></h2><div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.Linear.html" title="frame_support::benchmarking::Linear struct">Linear</a></div><div class="item-right docblock-short">Used by the new benchmarking code to specify that a benchmarking variable is linear
over some specified range, i.e. <code>Linear&lt;0, 1_000&gt;</code> means that the corresponding variable
is allowed to range from <code>0</code> to <code>1000</code>, inclusive.</div></div></div><h2 id="traits" class="small-section-header"><a href="#traits">Traits</a></h2><div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="trait" href="trait.ParamRange.html" title="frame_support::benchmarking::ParamRange trait">ParamRange</a></div><div class="item-right docblock-short">Trait that must be implemented by all structs that can be used as parameter range types
in the new benchmarking code (i.e. <code>Linear&lt;0, 1_000&gt;</code>). Right now there is just
<a href="struct.Linear.html" title="Linear"><code>Linear</code></a> but this could later be extended to support additional non-linear parameter
ranges.</div></div></div><h2 id="attributes" class="small-section-header"><a href="#attributes">Attribute Macros</a></h2><div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="attr" href="attr.benchmark.html" title="frame_support::benchmarking::benchmark attr">benchmark</a></div><div class="item-right docblock-short">An attribute macro used to declare a benchmark within a benchmarking module. Must be
attached to a function definition containing an <code>#[extrinsic_call]</code> or <code>#[block]</code>
attribute.</div></div><div class="item-row"><div class="item-left module-item"><a class="attr" href="attr.benchmarks.html" title="frame_support::benchmarking::benchmarks attr">benchmarks</a></div><div class="item-right docblock-short">An attribute macro that can be attached to a (non-empty) module declaration. Doing so will
designate that module as a benchmarking module.</div></div><div class="item-row"><div class="item-left module-item"><a class="attr" href="attr.block.html" title="frame_support::benchmarking::block attr">block</a></div><div class="item-right docblock-short">An attribute macro used to specify that a block should be the measured portion of the
enclosing benchmark function, This attribute is also used as a boundary designating where
the benchmark setup code ends, and the benchmark verification code begins.</div></div><div class="item-row"><div class="item-left module-item"><a class="attr" href="attr.extrinsic_call.html" title="frame_support::benchmarking::extrinsic_call attr">extrinsic_call</a></div><div class="item-right docblock-short">An attribute macro used to specify the extrinsic call inside a benchmark function, and also
used as a boundary designating where the benchmark setup code ends, and the benchmark
verification code begins.</div></div><div class="item-row"><div class="item-left module-item"><a class="attr" href="attr.instance_benchmarks.html" title="frame_support::benchmarking::instance_benchmarks attr">instance_benchmarks</a></div><div class="item-right docblock-short">An attribute macro that can be attached to a (non-empty) module declaration. Doing so will
designate that module as an instance benchmarking module.</div></div></div></section></div></main><div id="rustdoc-vars" data-root-path="../../" data-static-root-path="../../static.files/" data-current-crate="frame_support" data-themes="" data-resource-suffix="" data-rustdoc-version="1.67.0-nightly (a00f8ba7f 2022-11-15)" data-search-js="search-df80cc3cb87b6482.js" data-settings-js="settings-7873449fa8c00e11.js" data-settings-css="settings-af96d9e2fc13e081.css" ></div></body></html>